[{"content":"The cover picture is salt piles and condenser ponds in Bonaire, Dutch Caribbean. Picture source.\nWhat is Binary Search? Binary Search is a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(log n)\nSteps:\nBegin with the mid element of the whole array as a search key. if the value of the search key is equal to the item then return an index of the search key Or if the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half Repeatedly check from the second point until the value is found or the interval is empty. ğŸ Although the logic of the algorithm is very simple, I believe we all meet the problem ğŸ’© whether to use \u0026lt;= or \u0026lt;, whether to use left = mid + 1 or left = mid. When the iteration is end, which result (left or right) should I return?\nI will introduce two different implementation of the algorithm. Of Course, they are bug free !!!!!!!! ğŸ˜†ğŸ˜†ğŸ˜†ğŸ˜†\nReturn the first value that is no less than the target The array should be non-descending order !!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public int lower_bound(int[] array, int left, int right, int target) { while(left \u0026lt; right) { int mid = left + (right - left) / 2; if(array[mid] \u0026lt; target) { left = mid + 1; }else { right = mid; } } return left; } int left = 0; int right = array.length; For example: array: 0 1 2 3 3 3 4 5 6 target: 3 Return index: 3 array: 0 1 2 4 5 6 target: 3 Return index:3 (the result is index 3, which is 4) The searching interval is [left, right)\nint mid = left + (right - left) / 2; is to avoid the Integer overflow.\nReturn the first value that is greater than the target The array should be non-descending order !!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public int upper_bound(int[] array, int left, int right, int target) { while(left \u0026lt; right) { int mid = left + (right - left) / 2; if(array[mid] \u0026lt;= target) { left = mid + 1; }else { right = mid; } } return left; } int left = 0; int right = array.length; For example: array: 0 1 2 3 3 3 4 5 6 target: 3 Return index: 6 (the reuslt is index 6, which is 4) array: 0 1 2 4 5 6 target: 3 Return index: 3 (the result is index 3, which is 4) The searching interval is [left, right)\nThe biggest difference between upper_bound and lower_bound\nif the target is existed, the upper_bound will return the first value that is greater than the target. if the target is existed, the lower_bound will return the first index of the target in the array. The common of the two functions:\nif the target is not existed, they will return a index. if we insert target in this index, the array will be sill sorted. Reference Binary Search - GeeksforGeeks\n","date":"2022-06-17T00:00:00Z","image":"https://gemarkq.github.io/p/bug-free-binary-search-implementation/mountain_huaf1607a52375b10cd0b14df0a702d644_856544_120x120_fill_box_smart1_3.png","permalink":"https://gemarkq.github.io/p/bug-free-binary-search-implementation/","title":"Bug Free Binary Search Implementation"}]